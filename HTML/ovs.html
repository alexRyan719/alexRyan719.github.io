<!DOCTYPE html>
<!-- Reg: All right, but apart from the sanitation, medicine, education, wine, public order, irrigation, roads, the fresh water system and public health, what have the Romans ever done for us?
Attendee: Brought peace?
Reg: Oh, peace - shut up!
Reg: There is not one of us who would not gladly suffer death to rid this country of the Romans once and for all.
Dissenter: Uh, well, one.
Reg: Oh, yeah, yeah, there's one. But otherwise, we're solid. -->

<html>

  <head>
<!--     <link rel="stylesheet" type="text/css" href="./CSS/my_steeze.css"> -->
    <link rel="stylesheet" type="text/css" href="../CSS/oscs.css">
    <script src="../JS/oscs.js"></script>
<!--     <script src="myscripts.js"></script> -->
  </head>
  
  
  <body>
    

     <div id="brandRow">  
      <button onclick="switchBrand('matrix')">Matrix</button>
      <button onclick="switchBrand('citrusine_')">Citrusine_</button>
      <button onclick="switchBrand('standard')">Standard</button>
      <button onclick="switchBrand('submarine')">Submarine</button>
      <button onclick="switchBrand('pistachio')">Pistachio</button>
      <button onclick="switchBrand('elFuego')">El Fuego</button>
    </div>


    <div>
      <!-- <img src="../IMG/math_blaster_cover.jpg" alt="math blaster cover">
      <p>
        Math Blaster was one of my favorite learning tools. It was an early example of gameification. 
      </p> -->
      <h3>
        OVS - Online Voting System
      </h3>

      <p>
        This is a concept for an Online Voting System through email and verified publicly via a website. 
      </p>

    </div>


    <div>
      <h1>
        
      </h1>
      <p>
        Using Minikube to Create a Cluster
Objectives
 - Learn what a Kubernetes cluster is.
 - Learn what Minikube is.
 - Start a Kubernetes cluster on your computer.

        
Kubernetes Clusters
Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) 
        and execution of application containers within and across computer clusters.
Kubernetes coordinates a highly available cluster of computers that are connected to work as a single 
        unit. The abstractions in Kubernetes allow you to deploy containerized applications to a cluster 
        without tying them specifically to individual machines. To make use of this new model of 
        deployment, applications need to be packaged in a way that decouples them from individual hosts: 
        they need to be containerized. Containerized applications are more flexible and available than 
        in past deployment models, where applications were installed directly onto specific machines as 
        packages deeply integrated into the host. Kubernetes automates the distribution and scheduling 
        of application containers across a cluster in a more efficient way. Kubernetes is an open-source 
        platform and is production-ready.

A Kubernetes cluster consists of two types of resources:

The Control Plane coordinates the cluster
Nodes are the workers that run applications
Cluster Diagram

The Control Plane is responsible for managing the cluster. The Control Plane coordinates all activities 
        in your cluster, such as scheduling applications, maintaining applications' desired state, 
        scaling applications, and rolling out new updates.

Control Planes manage the cluster and the nodes that are used to host the running applications.
A node is a VM or a physical computer that serves as a worker machine in a Kubernetes cluster. Each 
        node has a Kubelet, which is an agent for managing the node and communicating with the 
        Kubernetes control plane. The node should also have tools for handling container operations, 
        such as containerd or CRI-O. A Kubernetes cluster that handles production traffic should 
        have a minimum of three nodes because if one node goes down, both an etcd member and a 
        control plane instance are lost, and redundancy is compromised. You can mitigate this 
        risk by adding more control plane nodes.

When you deploy applications on Kubernetes, you tell the control plane to start the application 
        containers. The control plane schedules the containers to run on the cluster's nodes. 
        Node-level components, such as the kubelet, communicate with the control plane using 
        the Kubernetes API, which the control plane exposes. End users can also use the 
        Kubernetes API directly to interact with the cluster.

A Kubernetes cluster can be deployed on either physical or virtual machines. To get started 
        with Kubernetes development, you can use Minikube. Minikube is a lightweight 
        Kubernetes implementation that creates a VM on your local machine and deploys a 
        simple cluster containing only one node. Minikube is available for Linux, macOS, 
        and Windows systems. The Minikube CLI provides basic bootstrapping operations for 
        working with your cluster, including start, stop, status, and delete.
      </p>
    </div>
  </body>
</html>

<!-- For the files of this project, see my GitHub repo here:

https://github.com/alexRyan719/playground-zdecbj78/tree/master

Welcome!
First off, this is not meant to be political in any way. Rather, this is a potential solution to the ugliness politics has often become.  If this is done correctly, it should be able to be used in any country, state, province, territory, county, city, region. 

How does it work?
The idea is to allow registered voters to use their email account to cast their vote. First, every registered voter would need to link an email address to their government ID. This should be done in person, but can be updated with a video call (Google Meets, Zoom, etc). A hash can be generated for every election or however frequently is needed. The government ID numbers should still stay hidden, but the email and the name can be less protected. The votes would be mostly seen by computer / robot eyes only. The only times any humans would look at votes is if the voter claimed their vote was changed or inaccurate.

Why Email?
Most email servers allow Multi Factor Authentication. As long as the email account is protected with strong MFA (authenticator apps are preferred, passkeys should be available / robust soon), then we can guarantee only the actual registered voter has access. There are still ways to break MFA, but there are ways to detect those ways. It's all traceable. Once you have a trusted accounting of only one valid email address per registered voter, you can prove that only currently registered voters are able to vote. 

Below is an example of how to generate a simple hash for a unique voter ID. This would be sent to each registered voter. The voter would respond to that email with their vote. By using a newly generated hash every election (date or election id can be added to the hash input), you can post a list of all those IDs and the corresponding vote on websites. After the polls close, every voter would be asked to check that their vote is accurate. They would copy the hash ID from their email, do a find on the website for it, and verify their vote is accurate.

How do you vote?
An email would be sent to every registered email address with an underscore next to each candidate's first name, last name, and party. The voter would copy the text and replace the underscore with an X (or literally anything else, even just erase the underscore). As long as it's not an underscore, it's marked as the selection. That reply is sent with the choices indicated. A machine would read incoming emails, check against a list of all emails, and then log the vote for the email address.That database entry would then be used to update the vote database.

How do you display the results, in real time, so anyone at home can see the vote counts?
We would need a web server / website for every state, and maybe even every county for larger counties. This is relatively easy to do, as we're just working with linking databases to web servers as display only. The actual changes happen on the back end with emails in an email server (that has all the bells and whistles of cyber security Blue Teaming). Every vote is displayed as a line item that starts with the unique voter ID we create for every voter. By changing the hash every election and emailing a new one, it wouldn't matter if someone figured out who the person was behind the voter ID.

This would not only let them know it was counted, but counted accurately. If the vote isn't correct, the voter would send an email notifying the voter administrators. They would change the vote and log the change. There would be as many iterations of this as needed. Or, in other words, there would be a few "check again" corrections to the votes. This gives us traceable logs to investigate any fraud. Backup email addresses could be requested and those emails used to confirm identity (other registered voter that will vouch, held accountable for fraud). Or, any other combination of investigion tactics are possible with email logs and headers. -->

    
